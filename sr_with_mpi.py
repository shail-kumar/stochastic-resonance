#! /home/shailen/miniconda2/bin/python
"""
This program evolves the following coupled ODEs with dichotomous noise, using predictor-corrector method:
dx1/dt = ...
dx2/dt = ...

The program is parallelized with mpi4py.

@author:	Shailendra K Rathor
			Department of Physics,
			Indian Institute of Technology, Kanpur (India)
			
@Note: If you find it useful please do use, modify or distribute it.
"""

from __future__ import division
import numpy as np
import matplotlib.pyplot as plt
import datetime
import os
from scipy.signal import hilbert
#~ from statsmodels.tsa import stattools
from mpi4py import MPI


def generate_DN(state1, state2, tau, stepsize, boxsize = 1):
	a = float(state1)		# state_1
	b = float(state2)		# state_2
	mu_a = a/(a-b) * (1/tau)
	mu_b = (-1.0)* b * mu_a / a
	dt = stepsize
	x0 = a
	X = [x0]		# Sequence generated by random variable eta(t)
	length = int(float(boxsize)/stepsize)
	P_aa = tau*(mu_b + mu_a*np.exp(-dt/tau))
	P_ab = tau*(mu_b - mu_b*np.exp(-dt/tau))
 
	for _ in range(length):
		if(X[-1] == x0):
			R = np.random.uniform(0.0,1.0,size=1)
			if(R < P_aa):
				x1 = a
				X.append(x1)
			else:
				x1 = b
				X.append(x1)
		else:		
			R = np.random.uniform(0.0,1.0,size=1)
			if(R < P_ab):
				x1 = a
				X.append(x1)
			else:
				x1 = b
				X.append(x1)
		
	X = np.array(X)
	T = dt*np.arange(len(X))

	return (T,X)

def plot_of_DN():
	T, X = generate_DN(6,-4,0.5,0.001,100)
	plt.plot(T,X)
	plt.show()
	return 0

def predictor_corrector(t0,x0,y0, dt, stiffness = 2, xi = 0, epsilon = 1, Amp = 1, freq = 2*np.pi):
	f0 = epsilon * y0 + Amp*np.sin(freq * t0) - (stiffness + xi) * x0  #rhs(t0, x0, y0)
	predicted_x1 = x0 + dt * f0
	t1 = t0+dt
	#~ f1 = rhs(t1, predicted_x1, y0)
	#~ predicted_x1 = x0 + 0.5*dt*(f0 + f1)
	f1 = epsilon * y0 + Amp*np.sin(freq * t1) - (stiffness + xi) * predicted_x1  #rhs(t1, predicted_x1, y0)
	corrected_x1 = x0 + 0.5*dt*(f0 + f1)
	return corrected_x1

def evolution_with_mpi():
	""" This evolves the Langevin's equations with noise.
	Parameter
	---------
	sigma:
	lambda:
	stiffness:
	forcing ampilitude:
	forcing frequency:
	
	Returns
	------
		
	"""
	comm = MPI.COMM_WORLD
	rank = comm.Get_rank()
	size = comm.Get_size()
	
	out_dir = "/scratch/skrathor/aman/"
	attempt = 6 #input("Attempt number for evolution: ", ) # Return a string
	
	runHistory_path = "run_history/attempt-"+str(attempt)
	# ==== Creation of directory if it doesn't exit =======
	if rank == 0:
		dir_nod = os.path.exists(runHistory_path)
		if(dir_nod == False):
			os.makedirs(runHistory_path)
	# =====================================================		
	comm.Barrier()		# Wait till the directory is created.
	
	f = open(runHistory_path+"/history-"+str(rank)+".txt", "a")
	now = datetime.datetime.now().strftime("%H:%M:%S, %d/%m/%Y")
	f.writelines(["\nRun attempt: ", str(attempt), "\n"])
	f.writelines(["Start time: ", str(now), "\n"])

	# ==== Input for noise generation =======================
	sigma_values = np.arange(2.0, 2.4, 0.02)
	#~ sigma_values = [2.1,2.2,2.3]
	T = 20.0										# Domain size
	f.writelines(["\t Domain size: ", str(T), "\n"])
	sigma_1 = sigma_values[rank] #2.5							# state 1
	f.writelines(["\t State 1: ", str(sigma_1), "\n"])
	sigma_2 = sigma_1							# state 2
	f.writelines(["\t State 2: ", str(sigma_2), "\n"])
	tau_1 = 0.1									# typical time of autocorrelation for x_1
	f.writelines(["\t tau_1: ", str(tau_1), "\n"])
	tau_2 = 0.1										# typical time of autocorrelation for x_2
	f.writelines(["\t tau_2: ", str(tau_2), "\n"])
	tau = np.min([tau_1, tau_2])
	numerator = 10**(np.floor(np.log10(tau))) 		# order of tau
	dt = numerator/100.0							# time step s.t. dt << tau
	f.writelines(["\t stepsize: ", str(dt), "\n"])
	
	# ==== Input for the set of equations ====================
	#~ dt = 0.01									# stepsize, Determined from tau s.t. dt << tau. See above.
	N = int(T/dt)									# Number of steps
	eps = 0.0										# coupling strength
	f.writelines(["\t epsilon: ", str(eps), "\n"])
	a = 1.0											# Stiffness
	f.writelines(["\t stiffness: ", str(a), "\n"])
	A = 1.0											# Forcing amplitude
	f.writelines(["\t amplitude: ", str(A), "\n"])
	omega = 2.8										# Forcing frequency
	f.writelines(["\t frequency: ", str(omega), "\n"])
	# =========== For ensemble averaging ====================
	ensemble_size = 25000		# For progress bar to work take it >= 100
	f.writelines(["\t ensemble size: ", str(ensemble_size), "\n"])
	f.close()
	
	
	if rank == 0:
		X_total = 0
		Y_total = 0
		ensemble_size_by_100 = ensemble_size/100
		print("==== Progress bar =====")
		for ic in range(ensemble_size):
			if(ic % ensemble_size_by_100 == 0):
				progress = round(ic/ensemble_size * 100)
				print(progress,"% | ",end='', flush=True)
			t0 = 0											# initial time
			x0 = 0											# initial condition on x_1
			y0 = 0											# initial condition on x_2
			X = [x0]										# Sequence of x_1 to evolve
			Y = [y0]										# Sequence of x_2 to evolve
			_, xi_1 = generate_DN(sigma_1,-sigma_1, tau_1, dt, boxsize=T) 	# generate noise for x_1
			#~ _, xi_2 = generate_DN(sigma_2,-sigma_2, tau_2, dt, boxsize=T) 	# generate noise for x_2
			# =========== Loop for evolution ===================================
			for i in range(1,N+1):
				t0 = i*dt
				x = predictor_corrector(t0, x0, y0, dt, stiffness = a, xi = xi_1[i], epsilon = eps, Amp = A, freq = omega)
				y = 0 # predictor_corrector(t0, y0, x0, dt, stiffness = a, xi = xi_2[i], epsilon = eps, Amp = A, freq = omega)
				#~ x = predictor_corrector(t0, x0, y0, dt, stiffness = a, xi = 0, epsilon = eps, Amp = A, freq = omega)
				#~ y = predictor_corrector(t0, y0, x0, dt, stiffness = a, xi = 0, epsilon = eps, Amp = A, freq = omega)
				x0 = x
				y0 = y
				X.append(x)
				Y.append(y)
			X_total += np.array(X)
			Y_total += np.array(Y)
		X_mean = X_total / ensemble_size
		Y_mean = Y_total / ensemble_size
		t = dt * np.arange(N+1)
		sigma = '{:1.2f}'.format(sigma_1)
		output_path = out_dir + "data_with_sigma/xy_t-"+str(attempt)
		dir_nod = os.path.exists(output_path)
		if(dir_nod == False):
			os.makedirs(output_path)
		np.savetxt(output_path+"/sigma-"+str(sigma)+".txt", np.column_stack((t, X_mean, Y_mean)))
			
		now = datetime.datetime.now().strftime("%H:%M:%S, %d/%m/%Y")
		
		f = open(runHistory_path+"/history-"+str(rank)+".txt", "a")
		f.writelines(["End time: ", str(now), "\n"])
		f.writelines(["\n-----------------------------\n"])
		f.close()
		
		print(100, "%.\n DONE!")

	if rank != 0:
		X_total = 0
		Y_total = 0
		for ic in range(ensemble_size):
			t0 = 0											# initial time
			x0 = 0											# initial condition on x_1
			y0 = 0											# initial condition on x_2
			X = [x0]										# Sequence of x_1 to evolve
			Y = [y0]										# Sequence of x_2 to evolve
			_, xi_1 = generate_DN(sigma_1,-sigma_1, tau_1, dt, boxsize=T) 	# generate noise for x_1
			_, xi_2 = generate_DN(sigma_2,-sigma_2, tau_2, dt, boxsize=T) 	# generate noise for x_2
			# =========== Loop for evolution ===================================
			for i in range(1,N+1):
				t0 = i*dt
				x = predictor_corrector(t0, x0, y0, dt, stiffness = a, xi = xi_1[i], epsilon = eps, Amp = A, freq = omega)
				y = 0 # predictor_corrector(t0, y0, x0, dt, stiffness = a, xi = xi_2[i], epsilon = eps, Amp = A, freq = omega)
				#~ x = predictor_corrector(t0, x0, y0, dt, stiffness = a, xi = 0, epsilon = eps, Amp = A, freq = omega)
				#~ y = predictor_corrector(t0, y0, x0, dt, stiffness = a, xi = 0, epsilon = eps, Amp = A, freq = omega)
				x0 = x
				y0 = y
				X.append(x)
				Y.append(y)		
			X_total += np.array(X)
			Y_total += np.array(Y)
		X_mean = X_total / ensemble_size
		Y_mean = Y_total / ensemble_size
		t = dt * np.arange(N+1)
		sigma = '{:1.2f}'.format(sigma_1)
		output_path = out_dir + "data_with_sigma/xy_t-"+str(attempt)
		dir_nod = os.path.exists(output_path)
		if(dir_nod == False):
			os.makedirs(output_path)
		np.savetxt(output_path+"/sigma-"+str(sigma)+".txt", np.column_stack((t, X_mean, Y_mean)))
			
		now = datetime.datetime.now().strftime("%H:%M:%S, %d/%m/%Y")
		
		f = open(runHistory_path+"/history-"+str(rank)+".txt", "a")
		f.writelines(["End time: ", str(now), "\n"])
		f.writelines(["\n-----------------------------\n"])
		f.close()
	
	return 0
	
def plot_of_signal():
	#~ attempt = input("Attempt number for plotting: ", ) # Return a string
	#~ data = np.loadtxt("data/xy-t_"+str(attempt)+".txt")
	out_dir = "/scratch/skrathor/aman/"
	attempt = 6
	#~ sigma_values = np.arange(0.1, 2.0, 0.1)
	sigma_values = np.arange(2.0, 2.4, 0.02)
	for sigma in sigma_values:
		sigma = '{:1.2f}'.format(sigma)
		data = np.loadtxt(out_dir+"data_with_sigma/xy_t-"+str(attempt)+"/sigma-"+str(sigma)+".txt")
		max_index = -1 #int(0.2*data.shape[0])
		t = data[:max_index,0]
		X = data[:max_index,1]
		#~ Y = data[:max_index,2] + 0.3375
		# ============== Plotting ==========================================
		plt.plot(t, X, label=sigma)
	Y = data[:max_index,2] + 0.3375
	plt.plot(t, Y, label=r"$x_2$")
	Y = data[:max_index,2] - 0.3375
	plt.plot(t, Y, label=r"$x_2$")
	
	
	#~ data = np.loadtxt(out_dir+"data_with_sigma/xy_t-2/sigma-2.20.txt")
	#~ max_index = -1 #int(0.2*data.shape[0])
	#~ t = data[:max_index,0]
	#~ X1 = data[:max_index,1]
	#~ Y = data[:max_index,2] + 0.3375
	# ============== Plotting ==========================================
	#~ plt.plot(t, X1, label=r"$x_1$, 1000")
	
	#~ data = np.loadtxt(out_dir+"data_with_sigma/xy_t-3/sigma-2.20.txt")
	#~ max_index = -1 #int(0.2*data.shape[0])
	#~ t = data[:max_index,0]
	#~ X2 = data[:max_index,1]
	#~ Y = data[:max_index,2] + 0.3375
	# ============== Plotting ==========================================
	#~ plt.plot(t, X2, label=r"$x_1$, 20000")
	
	#~ X_avg = (X*10000 + X1 * 1000 + X2 * 20000) / (31000)
	# ============== Plotting ==========================================
	#~ plt.plot(t, X_avg, label=r"$x_1$, avg")
	#~ plt.plot(t, Y, label=r"$x_2$")
	#~ plt.plot(t, Veff,'--o', label=r"$x$")
	#~ plt.plot(t, Veff, label=r"$y$")
	plt.xlabel(r"$t$")
	plt.ylabel(r"$x_1, x_2$")
	#~ plt.ylim(1e-5, 1e5)
	plt.legend(loc="best")
	plt.tight_layout()
	plt.show()
	#~ plt.savefig("test_0.1.png")

def amplitude():
	attempt = 6
	out_dir = "/scratch/skrathor/aman/"

	sigma_values = np.arange(2.0, 2.4, 0.02)
	A1 = []
	A2 = []
	for sigma in sigma_values:
		sigma = '{:1.2f}'.format(sigma)
		#~ attempt = input("Attempt number for plotting: ", ) # Return a string
		data = np.loadtxt(out_dir+"data_with_sigma/xy_t-"+str(attempt)+"/sigma-"+str(sigma)+".txt")
		min_index = int(0.4*data.shape[0])
		max_index = int(0.9*data.shape[0])
		#~ a1 = np.max(data[:max_index,1]) - np.mean(data[:max_index,1])
		#~ a2 = np.max(data[:max_index,2]) - np.mean(data[:max_index,2])
		a1 = np.max(data[min_index:max_index,1]) *2 #+ np.min(data[:max_index,1])
		a2 = np.max(data[min_index:max_index,2]) * 2#+ np.min(data[:max_index,2])
		A1.append(0.5 * a1)
		A2.append(0.5 * a2)
	A1 = np.array(A1)
	A2 = np.array(A2)
	np.savetxt("amplitudes_"+str(attempt)+".txt", np.column_stack((sigma_values, A1, A2)))
	#~ print(A1, A2)
	return 0
	
def amp_using_hilbert_transform():
	attempt = 23
	#~ sigma_values = np.arange(1.8, 2.3, 0.01)
	sigma_values = np.arange(1.8, 2.3, 0.01)

	A1 = []
	#~ A2 = []
	fig = plt.figure()

	for sigma in sigma_values:
		sigma = '{:1.2f}'.format(sigma)
		#~ attempt = input("Attempt number for plotting: ", ) # Return a string
		data = np.loadtxt("data_with_sigma/xy_t-"+str(attempt)+"_sigma-"+str(sigma)+".txt")
		
		t = data[:,0]
		signal = data[:,1]
		analytic_signal = hilbert(signal)
		amplitude_envelope_plus = np.abs(analytic_signal)
		amplitude_envelope_minus = np.abs((-1)*analytic_signal)
		#~ instantaneous_phase = np.unwrap(np.angle(analytic_signal))
		#~ instantaneous_frequency = (np.diff(instantaneous_phase) /
								   #~ (2.0*np.pi) * fs)

		#~ fig = plt.figure()
		#~ ax0 = fig.add_subplot(111)
		#~ ax0.plot(t, signal, label=sigma)
		#~ ax0.plot(t, amplitude_envelope, label=str(sigma)+'envelope')
		#~ ax0.set_xlabel("time in seconds")
		#~ ax0.legend()
		#~ ax1 = fig.add_subplot(212)
		#~ ax1.plot(t[1:], instantaneous_frequency)
		#~ ax1.set_xlabel("time in seconds")
		#~ ax1.set_ylim(0.0, 120.0)
	#~ plt.show()
		amplitude_envelope = 0.5*(amplitude_envelope_plus + amplitude_envelope_minus)
		min_index = int(0.1*data.shape[0])
		max_index = int(0.9*data.shape[0])
		a1 = np.mean(amplitude_envelope[min_index:max_index])
		A1.append(a1)
		#~ A2.append(a2)
	A1 = np.array(A1)
	#~ A2 = np.array(A2)
	np.savetxt("amplitudes_hilbert_"+str(attempt)+".txt", np.column_stack((sigma_values, A1)))
	
def plot_amp_vs_sigma():
	attempt = 6
	data = np.loadtxt("amplitudes_"+str(attempt)+".txt")
	#~ data = np.loadtxt("amplitudes_"+str(attempt)+".txt")
	max_index = data.shape[0]
	sigma_values = data[:max_index,0]
	A1 = data[:max_index,1]
	#~ A2 = data[:max_index,2]
	plt.plot(sigma_values, A1, '--o')
	#~ plt.plot(sigma_values, A2, '--s')
	plt.show()

if __name__ == '__main__':
	#~ generate_DN()
	#~ evolution_with_mpi()
	plot_of_signal()
	#~ amplitude()
	#~ amp_using_hilbert_transform()
	#~ plot_amp_vs_sigma()
	#~ print ("Check if any function is selected otherwise it is Successful !")
